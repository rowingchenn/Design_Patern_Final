# 软件设计模式期末项目文档

## 课程情况
2023 Fall 史扬 周三下午 9-11 节
## 组员
 张唯琛 2151414

## 项目概要

本项目由6个子系统组成，每个子系统由3个模块组成
1. 子系统功能概述
2. 子系统总 UML 类图
3. 设计模式
    1. A 设计模式
        1. 模式应用场景【说明这个模式在本子系统中实现怎样的作用】
        2. 该设计模式的 UML 类图
        3. 说明各个类的作用以及设计思路【格式不限】
        4. 贴代码
        5. 代价说明（使用此设计模式的负面代价）
   1. B 设计模式

## 全局命令子系统-lrk

### 功能概述

### UML 类图

### 设计模式
#### 模块模式
##### 模式应用场景
##### 模式UML类图
##### 模式设计思路
##### 核心代码
##### 代价说明


## 顾客子系统

## 店铺子系统

## 商品子系统

## 活动与广告子系统

####	功能与实现

##### 广告子系统

+ 主要功能：

  1. 添加广告
  2. 浏览广告

+ 实现方案：

  1. 结构体AdNode代表的变量类型用于存储一个广告的具体内容，包括广告ID以及广告内容。

     ```cpp
     struct AdNode//广告
     {
         int AdID;
         string Content;
     
         AdNode(int ID, string Cont)
         {
             AdID = ID;
             Content = Cont;
         }
     };
     ```

     

  2. AdvertisingSystem类用于对所有当前存在的广告进行管理，是广告系统的主体，通过开放Accept函数使用Visitor模式进行功能实现与扩展。为了保持广告系统的唯一性，使用了单例模式。

     ```cpp
     class AdvertisingSystem//广告子系统（单例）
     {
     public:
         ~AdvertisingSystem();
     
         static AdvertisingSystem* GetAdSystemInstance();
     
         void Accept(AdVisitor* Visitor);
     
         void PrintAd(int Index);//打印广告
     
     private:
     
         AdvertisingSystem();
     
         static AdvertisingSystem* AdSystemInstance;
     
         vector<AdNode*> AdvertisingList;
     };
     ```

  3. AdVisitor类作为AdvertisingSystem的访问者，用于实现与扩展广告系统的功能，并保持AdvertisingSystem类的简洁性。AdVisitor_Browse类与AdVisitor_Add类均继承于AdVisitor类，分别实现了广告系统的浏览功能和添加功能。

     ```cpp
     class AdVisitor//广告visitor父类
     {
     public:
     
         virtual ~AdVisitor() = default;
     
         virtual void Visit(AdvertisingSystem* AdSystem) = 0;
     };
     class AdVisitor_Browse : public AdVisitor//浏览广告visitor子类
     class AdVisitor_Add : public AdVisitor//添加广告visitor子类
     ```

##### 活动子系统

+ 主要功能：

  1. 添加活动
  2. 浏览活动
  3. 计算活动价格并选择最优方案
  4. 根据商品推荐相关活动

+ 实现方案：

  1. AcNode类是单个活动的基类，用于存储所有活动都拥有的内容，包括活动ID以及活动内容。

     ```cpp
     class AcNode//活动父类
     {
     public:
     
         AcNode(int ID, string Cont);//两类活动id不可相同
         
         int AcID;
         string Content;
     };
     ```

     从AcNode类派生出两个子类：AcNode_Discount、AcNode_FullReduction，分别代表打折类活动和满减类活动。

     AcNode_Discount中存储了打折商品列表以及打折力度这两个关键属性，AcNode_FullReduction中存储了满减的阈值以及力度这两个关键属性。

     通过这些关键属性便可以提供：1.是否能使用该活动；2.使用该活动的价格为多少，这两个函数，进一步便可以提供完整的“ ExecuteActivity”这个函数用于获取通过该活动的价格。

     ```cpp
     class AcNode_Discount : public AcNode//打折类活动子类
     {
     public:
     
         AcNode_Discount(int ID, string Cont, vector<int>& CommodityInformationIDList, float DisRate);
         
         float ExecuteActivity(CommodityInformation* BuyCommodityInformation, int Amount); // 若商品打折，则返回商品打完折的价格，否则返回原价
     
         bool IsSatisfy(CommodityInformation* BuyCommodityInformation);//判断商品是否打折
     
     private:
     
         float CalPrice(CommodityInformation* BuyCommodityInformation, int Amount);//返回商品打完折后的价格
     
         vector<int> SatisfyCommodityInformationIDList;
     
         float DiscountRate;
     };
     
     class AcNode_FullReduction : public AcNode//满减类活动子类
     {
     public:
     
         AcNode_FullReduction(int ID, string Cont, float Thd, float RedAmount);
     
         float ExecuteActivity(map<CommodityInformation*, int>& BuyCommodityInformation); //若商品达到满减金额，则返回商品满减后的价格，否则返回原价
     
     private:
     
         bool IsSatisfy(map<CommodityInformation*, int>& BuyCommodityInformation);//判断商品是否满减
     
         float CalPrice(map<CommodityInformation*, int>& BuyCommodityInformation);//返回商品满减后的价格
     
         float Threshold;
         float ReductionAmount;
     };
     ```

  2. ActivitySystem类用于管理当前存在的活动，通过开放Accept函数使用Visitor模式进行功能实现与扩展。为了保持活动系统的唯一性，使用了单例模式。因为存在两种活动，为了处理起来更加高效，使用了两个vector分别对其进行存储。

     ```cpp
     class ActivitySystem//活动子系统
     {
     public:
         ~ActivitySystem();
     
         static ActivitySystem* GetAcSystemInstance();
     
         void Accept(AcVisitor* Visitor);
     
         void PrintAc_D(int Index);//打印打折类活动
         void PrintAc_F(int Index);//打印满减类活动
     
     private:
     
         ActivitySystem();
     
         static ActivitySystem* AcSystemInstance;
     
         vector<AcNode_Discount*> DiscountActivityList;
         vector<AcNode_FullReduction*> FullReductionActivityList;
     };
     ```

  3. AcVisitor类作为ActivitySystem的访问者类，用于实现与扩展活动系统的功能，并保持ActivitySystem类的简洁性。

     ```cpp
     class AcVisitor//活动Visitor父类
     {
     public:
         virtual ~AcVisitor() = default;
         virtual void Visit(ActivitySystem* AcSystem) = 0;
     };
     ```

     为了实现添加活动功能，派生出了AcVisitor_Add类：

     ```cpp
     class AcVisitor_Add : public AcVisitor//添加活动Visitor子类
     ```

     为了实现浏览活动功能，派生出了AcVisitor_Browse类：

     ```cpp
     class AcVisitor_Browse : public AcVisitor//浏览活动Visitor子类
     ```

     为了实现推荐活动功能，派生出了AcVisitor_Recommend类：

     ```cpp
     class AcVisitor_Recommend : public AcVisitor//推荐活动Visitor子类
     ```

     为了实现计算最优价格功能，派生出了AcVisitor_CalPrice类，因为存在两种活动方式（打折、满减），且两种活动计算价格的方法以及输入都不一样，故需要分开处理，所以再从AcVisitor_CalPrice类派生出AcVisitor_CP_Discount类和AcVisitor_CP_FullRedu类分别用于计算打折类活动价格和满减类价格：

     ```cpp
     class AcVisitor_CalPrice : public AcVisitor//计算最优活动Visitor子类
     class AcVisitor_CP_Discount : public AcVisitor_CalPrice//计算最优打折活动Visitor子类
     class AcVisitor_CP_FullRedu : public AcVisitor_CalPrice//计算最优满减活动Visitor子类
     ```

  4. Interpreter类用于解释活动方案并打印输出，在计算最优价格以及推荐活动这两个函数中都会涉及到对一些活动进行组织并给予显示，通过一个解释器使得这种组织更加方便和准确：

     ```cpp
     class Interpreter
     {
     public:
     
         Interpreter();
     
         void MakeInterpretation(string Code);//解释Code含义
     
     private:
         
         ActivitySystem* AcSystemInstance;
     };
     ```

#### UML类图

##### 广告子系统

![image-20231228091204718](D:\FormyVS\Design_Patern_Final-dev\img\广告子系统类图_tyx.png)

##### 活动子系统

![image-20231228091225646](D:\FormyVS\Design_Patern_Final-dev\img\活动子系统_tyx.png)

#### 设计模式

##### 解释器模式

###### 设计模式实现

本项目中采用了解释器模式来处理活动系统（`ActivitySystem`）的最优价格和推荐活动。在这个场景中，这种模式被用于解释和输出针对购物车中商品的优惠活动。

首先，`AcVisitor_CP_Discount` 和 `AcVisitor_CP_FullRedu` 类在访问 `ActivitySystem` 时，不是直接输出最优价格或推荐活动，而是构建一个字符串 `DecisionCode` 或 `RecommendCode`。这些字符串以特定的编码方式表示了最优活动方案或推荐活动列表。例如，在 `DecisionCode` 中，第一个字符标识需要解释的代码类型（最优活动方案），第二个字符标识活动类别（如打折或满减），接下来的字符代表具体活动的索引或者特定的活动配置。

解释器 `Interpreter` 类接受这样的编码字符串作为输入，并根据预定义的规则进行解释。这些规则与编码规则一一对应，确保了正确的输出。例如，如果 `Code[0] == '1'`，则表示需要解释的是最优活动方案。随后的字符根据其值被解释为特定类型的活动，如打折活动或满减活动。解释器会遍历这个字符串，并基于每个字符的含义打印出相应的活动细节。

这种方法的优点是它提供了一种灵活且解耦的方式来处理复杂的活动方案。通过将活动方案的生成和表示与实际的输出解释分离开，可以更容易地修改和扩展活动系统，同时保持代码的清晰和可维护性。

在下图的代码中，在计算最优价格时没有直接打印出最优价格方案，而是构造了一个表达最优活动方案的字符串`DecisionCode`，需要输出时再交给解释器进行解释输出。

```cpp
void AcVisitor_CP_Discount::Visit(ActivitySystem* AcSystem)
{
    string DecisionCode;
    DecisionCode.push_back('1'); // 1代表需要解释的Code为最优活动列表
    DecisionCode.push_back('1'); // 1代表所选方案为打折活动类
	……
    for (auto BuyCommodityInformation : SaveBuyCommodityInformationMap)
    {
        DecisionCode.push_back(120); // 后续位均代表对应的活动的下标，120即为不使用活动
        ……
        for (int i = 0; i < AcSystem->DiscountActivityList.size(); i++)
        {
            float CalPrice = ……
            if (CalPrice < MinPrice)
            {
                MinPrice = CalPrice;
                DecisionCode[DecisionCode.length() - 1] =static_cast<char>(i); // 对应位置存储对应活动下标
            }
        }
        TotalMinPrice += MinPrice;
    }

    OptimalPrice = TotalMinPrice;
    OptimalDecisionCode = DecisionCode;
}
void AcVisitor_CP_FullRedu::Visit(ActivitySystem* AcSystem)
{
    string DecisionCode;
    DecisionCode.push_back('1'); // 1代表需要解释的Code为最优活动列表
    DecisionCode.push_back('2'); // 2代表所选方案为满减活动类
	……
}
```

同样，在推荐活动是也没有直接打印所有推荐的活动，而是构建了一个表达推荐活动方案的字符串RecommendCode，需要输出时再交给解释器进行解释输出。

```cpp
void AcVisitor_Recommend::Visit(ActivitySystem* AcSystem)
{
    string RecommendCode;
    RecommendCode.push_back('2'); // 2代表需要解释的Code为推荐活动列表
    RecommendCode.push_back('-1'); // 与最优活动编码对齐

    set<int> RecommendAcSet;

    ……

    for (auto Elem : RecommendAcSet)
    {
        RecommendCode.push_back(static_cast<char>(Elem)); // 每一位均存储一个相关的活动的下标
    }

    RecommendActivityCode = RecommendCode;
}
```

解释器接受一个字符串输入进行解释，解释规则与编码规则一一对应：

```cpp
void Interpreter::MakeInterpretation(string Code)
{
    if (Code.length() < 2) // 长度小于2即是一个错误编码，正常编码位数均在两位以上
        return;

    if (Code[0] == '1') // 第一位为1代表需要解释的Code为最优活动方案
    {
        if (Code[1] == '1') // 第二位为1代表选择的活动类别为打折类活动
        {
            cout << "最优活动类别为打折类，具体配置如下：" << endl;
            for (int i = 2; i < Code.length(); i++)
            {
                if (Code[i] == 120) // 编码为120代表不使用活动或没有活动满足
                {
                    cout << "###第" << i-1 << "件商品不活动" << endl;
                    continue;
                }
                cout << "###第" << i-1 << "件商品使用活动为：" << endl;
                AcSystemInstance->PrintAc_D(Code[i]); // 寻找对应的活动进行展示
            }
        }
        else if (Code[1] == '2') // 第二位为2代表选择的活动类别为满减类活动
        {
        	……
        }

    }
    else if (Code[0] == '2') // 第一位为2代表需要解释的Code为推荐活动方案
    {
        cout << "推荐活动为：" << endl;

        for (int i = 2; i < Code.length(); i++)
        {
            AcSystemInstance->PrintAc_D(Code[i]); // 对Code里的每一位代表的活动进行显示
        }
    }
}
```

###### UML类图

![image](https://user-images.githubusercontent.com/54826495/139690611-b0aac152-bc61-47bd-a719-9d67a454c921.png)

###### 代价分析

虽然解释器模式为处理复杂的活动方案提供了一种灵活和解耦的方法，但它也引入了维护和性能方面的挑战。这些挑战的影响取决于系统的规模、复杂性以及活动的种类和频率。

​			1. 维护成本

- **扩展性和灵活性的限制**：

  - 每当新增活动类型或更改活动规则时，都需要更新编码和解释的逻辑。例如，在 `AcVisitor_CP_Discount` 和 `AcVisitor_CP_FullRedu` 类中，为每种活动类型分配了不同的编码，若新增活动类型，则需要在这些类中添加新的编码逻辑。

  - 同样，解释器 `Interpreter` 也需要更新以识别和处理新的编码规则。这可能导致修改代码的复杂性增加，特别是当编码规则变得更加复杂时。

- **逻辑复杂性**：

  - 随着系统规模的增长，编码和解释逻辑可能变得越来越复杂。例如，`Interpreter` 类需要处理多种情况，如不同的活动类别（打折或满减）。如果活动类型和规则继续增加，保持这些逻辑的清晰和简洁可能会变得困难。

2. 性能开销

- 运行时解释开销：

  - 解释器模式在运行时对编码进行解释，这可能会导致性能开销。如果编码字符串非常长或者解释规则很复杂，这种开销可能变得显著。

  - 在大型或高频的系统中，这种运行时开销可能影响整体性能。例如，如果一个购物车包含大量商品，每个商品都有多种活动可供选择，那么解释这些活动的编码可能需要较多的计算资源。

##### 访问者模式

###### 设计模式实现

访问者的定义（源于GoF《Design Pattern》）是：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。
我们在设计 **广告与活动子系统** 时，不确定后续需要进行哪些操作，又不想在后续再修改原来类的代码，所以使用了 **访问者** 设计模式。
以 **广告子系统AdSystem** 为例，我们将说明 **访问者** 设计模式的实现：

1、**接受访问者**：在 `AdvertisingSystem` 类中，实现了一个 `Accept` 方法。这个方法允许 `AdSystem` 接受一个 `AdVisitor` 对象。`Accept` 方法的工作是调用访问者的 `Visit` 方法，并将自身（`this`）作为参数传递给访问者。这样，访问者就能对 `AdSystem` 实例进行操作。

在 **广告子系统AdSystem** 中写入 **Accept** 函数，用于获得 **访问者**：

```
class AdvertisingSystem
{
public:
    void Accept(AdVisitor* Visitor);
    ……
private:
    ……
};
```

**Accept** 函数的实现方法是：调用传入的 **访问者** 的 **Visit** 函数，将当前类实例传给 **访问者** 。

```
void AdvertisingSystem::Accept(AdVisitor *Visitor) {
    Visitor->Visit(this);
}
```

2、**定义访问者接口**：`AdVisitor` 是一个抽象类，定义了一个纯虚函数 `Visit`，这个函数是具体访问者类将要实现的部分。通过这个接口，不同的访问者可以定义对 `AdSystem` 的不同操作。

创建 **访问者** 的父类： **Visit** 函数表示要进行的具体操作，这里是纯虚函数，具体操作要在子类实现。

```
class AdVisitor//广告visitor父类
{
public:
    virtual ~AdVisitor() = default;
    virtual void Visit(AdvertisingSystem* AdSystem) = 0;
};
```

3、**实现具体的访问者**：每个具体的访问者，如 `AdVisitor_Add`，是 `AdVisitor` 的一个子类。它们实现了 `Visit` 方法，这样就可以在不修改 `AdSystem` 类的情况下，向 `AdSystem` 添加新的行为。例如，`AdVisitor_Add` 类在其 `Visit` 方法中实现了向 `AdSystem` 添加新广告的功能。

为每一个操作创建一个 **访问者** 的子类，以 **添加广告** 为例：
相较于 **访问者** 的父类，子类可以添加私有成员变量，如这里的 **广告编号AdID** 、**广告内容Content**；

```
class AdVisitor_Add : public AdVisitor
{
public:
    AdVisitor_Add(int ID, string Cont);
    void Visit(AdvertisingSystem* AdSystem) override;
private:
    int AdID;
    string Content;
};
```

子类需要自己的构造函数：如这里 **添加广告** 访问者子类的构造函数需要将参数传入：

```
AdVisitor_Add::AdVisitor_Add(int ID, string Cont)
{
    AdID = ID;
    Content = Cont;
}
```

**访问者子类** 的代表的具体操作将在 **Visit** 函数里实现：例如这里 **添加广告** 访问者子类的 **Visit** 函数实现如下：

```
void AdVisitor_Add::Visit(AdvertisingSystem* AdSystem)
{
    if (AdID < 0) // 验证广告编号合法性
    {
        cout << "ID < 0 !!!" << endl;
        return;
    }
    AdNode* ad = new AdNode(AdID, Content); // 创建广告实例
    AdSystem->AdvertisingList.push_back(ad); // 将广告加到广告集合
}
```

###### UML类图

![image](https://user-images.githubusercontent.com/54826495/139690681-20ab3e9a-b86a-49fb-813b-f1fcda9aabc1.png)

###### 代价分析

1. **抽象层次增加**：访问者模式引入了额外的抽象层次，如 `AdVisitor` 和其子类（例如 `AdVisitor_Add`）。这些抽象层次和间接性可能会使系统的整体结构更加复杂。

2. **不适用于频繁变化的对象结构：**如果 `AdvertisingSystem` 类的结构经常发生变化（比如添加新的属性或方法），那么可能需要频繁地更新所有相关的访问者类，如 `AdVisitor_Add`。这样的维护工作不仅繁琐，而且容易引入错误。

3. **性能开销**：访问者模式通常依赖于虚函数调用（如 `AdVisitor::Visit` 方法），这会带来额外的运行时开销，特别是在性能敏感的应用中可能会成为一个考虑因素。在实际操作中，例如添加广告，每次 `Accept` 调用都会涉及虚函数调用，这比直接在 `AdvertisingSystem` 类中实现相同功能的开销要高。

##### 策略模式

###### 设计模式实现

策略模式用于实现一个行为有多种选择的情况，并且将每种选择需要做的操作封装起来，方便调用。
我们这里在 **活动子系统** 的 **访问者AcVisitor** 中使用了策略模式，是为了更方便的区别使用 **打折类活动** 与 **满减类活动** 。
具体来说，我们需要找出购买一系列商品时，通过各种活动优惠后，最优的价格，在这里，我们有两种策略：一是参与 **打折类活动** ，二是参与 **满减类活动** ，然后对比两者谁更优惠。
在使用 **策略模式** 时，我们首先创建了指向所有策略的父类 **AcVisitor_CalPrice** 的指针，这个指针既可以指向 **打折策略类AcVisitor_CP_Discount** ，又可以指向 **满减策略类AcVisitor_CP_FullRedu** 。

```
float Facade::CalOptimalDecision(map<CommodityInformation*, int>& BuyCommodityInformationMap)
{
    AcVisitor_CalPrice* CalPriceVisitor;// 指向所有策略的父类
    
    CalPriceVisitor = new AcVisitor_CP_Discount(BuyCommodityInformationMap);// 策略1，使用打折活动
    AcSystemInstance->Accept(CalPriceVisitor);
    ……
    delete CalPriceVisitor;

    CalPriceVisitor = new AcVisitor_CP_FullRedu(BuyCommodityInformationMap);// 策略2，使用满减活动
    AcSystemInstance->Accept(CalPriceVisitor);
    ……
}
```

###### UML类图

![image](https://user-images.githubusercontent.com/54826495/139690727-d2648115-6d0d-449e-b1e0-7c1e1b780c69.png)

###### 代价分析

1. 增加类的数量：每个策略（如 `AcVisitor_CP_Discount` 和 `AcVisitor_CP_FullRedu`）都需要一个单独的类来实现。随着策略数量的增加，系统中的类数量也随之增加。

2. 运行时开销：策略通常通过接口或抽象类实现，这可能涉及到动态绑定，如在 `AcVisitor_CalPrice` 和其子类之间的关系。动态绑定（如虚函数调用）可能引入一些运行时开销，这在大量或频繁计算的场景中可能变得显著。

3. 对象生命周期管理：策略对象的创建和销毁需要谨慎管理。策略对象使用 `new` 创建并随后使用 `delete` 删除。如果不恰当地管理这些对象（如未正确删除或在需要时未重新创建），可能导致资源问题，如内存泄漏。


##### 外观模式

###### 设计模式实现

外观模式的意义在于，为几个子系统的对外接口提供一个统一的界面，使子系统更容易使用。
这里我们给予 **广告子系统AdvertisingSystem** 与 **活动子系统ActivitySystem**  一个外观：

```
class Facade//外观模式
{
public:

    Facade();//构造广告子系统、活动子系统、解释器

    // 广告操作：
    
    void BrowseAd();//浏览全部广告
    void BrowseAd(int BrowseAdID);//浏览单个广告
    void AddAd(int ID, string Cont);//添加单个广告

    // 活动操作：
    
    void BrowseAc();//浏览全部活动
    void BrowseAc(int BrowseAcID);//浏览单个活动
    void AddAcD(int ID, string Cont, vector<int>& CommodityInformationReaderList, float DisRate);
    //添加打折类活动
    void AddAcF(int ID, string Cont, float Thd, float RedAmount);
    //添加满减类活动
    float CalOptimalDecision(map<CommodityInformation*, int>& BuyCommodityInformationReaderMap);
    //寻求最优惠价格，并打印此时活动列表
    void RecommendActivity(vector<CommodityInformation*>& RelatedCommodityInformationReaderList);
    //打印与商品相关的所有活动
    void RecommendActivity(map<CommodityInformation*, int>& RelatedCommodityInformationReaderMap);
    //打印与商品相关的所有活动

private:
    AdvertisingSystem* AdSystemInstance;
    ActivitySystem* AcSystemInstance;
    Interpreter* ActivityInterpreter;
};
```

在外观构造函数中，我们生成了两个子系统与解释器的实例，并给它们添加了一系列初始化广告、活动内容；

```
Facade::Facade()
{
    AdSystemInstance = AdvertisingSystem::GetAdSystemInstance();// 广告子系统
    AcSystemInstance = ActivitySystem::GetAcSystemInstance();// 活动子系统
    ActivityInterpreter = new Interpreter();// 解释器

    AddAd(1, "双11开门红不熬夜！每日干果限量低价放送！");//添加广告
    ……
}
```

另外还定义了一系列其他子系统需要调用的接口，例如，**浏览所有广告** 操作，原本需要生成观察者 、Accept观察者、释放观察者三步操作，现在封装成一个函数 **BrowseAd** ，更加方便：

```
void Facade::BrowseAd()
{
    AdVisitor_Browse* AdBrowse = new AdVisitor_Browse();
    AdSystemInstance->Accept(AdBrowse);
    delete AdBrowse;
}
```

###### UML类图

![image](https://user-images.githubusercontent.com/54826495/139690809-f1141966-01b9-4a76-9dca-2476b1557431.png)

###### 代价分析

1. 可能产生单点故障：所有子系统操作都通过外观类 `Facade` 进行。如果 `Facade` 类本身存在缺陷或出现运行时错误，可能会影响到整个系统的操作和稳定性。

2. 功能访问受限：外观类提供了简化的接口来访问子系统的功能，如 `BrowseAd` 和 `AddAd` 方法。这种简化虽然对大多数用户来说足够，但对于需要更细粒度控制的高级用户来说，可能会隐藏子系统中更复杂的功能。如果客户端需要一些不在外观类中提供的特定功能，他们可能无法直接访问子系统的这些功能。

3. 附加的调用开销：外观模式通常涉及将调用从外观类转发到具体的子系统。这种额外的调用层可能会引入一些性能开销，尤其是在性能敏感的应用中。如 `BrowseAd` 方法，外观类实际上是在内部创建了一个访问者对象，将调用转发给了广告子系统。这个过程虽然对用户隐藏了复杂性，但也增加了额外的调用步骤。

## 订单子系统