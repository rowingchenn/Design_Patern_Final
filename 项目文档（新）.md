# 软件设计模式期末项目文档

## 课程情况
2023 Fall 史扬 周三下午 9-11 节
## 组员
 张唯琛 2151414
 孟雨昕 2151421
 胡芮宁 2153068

## 项目概要

本项目由6个子系统组成，每个子系统由3个模块组成
1. 子系统功能概述
2. 子系统总 UML 类图
3. 设计模式
    1. A 设计模式
        1. 模式应用场景【说明这个模式在本子系统中实现怎样的作用】
        2. 该设计模式的 UML 类图
        3. 说明各个类的作用以及设计思路【格式不限】
        4. 贴代码
        5. 代价说明（使用此设计模式的负面代价）
   1. B 设计模式

## 全局命令子系统-lrk

### 功能概述

### UML 类图

### 设计模式
#### 模块模式
##### 模式应用场景
##### 模式UML类图
##### 模式设计思路
##### 核心代码
##### 代价说明

## 顾客子系统

### 功能概述

本系统包含了有关用户信息的一系列操作，定义了订单、支付、个人信息等领域的功能和设计模式。主要包含的设计模式如下所示：

* 工厂模式：支付模块
* 状态模式：订单模块
* 原型模式：信息模块
* ......

### UML 类图

### 设计模式

#### 工厂模式

##### 模式应用场景

工厂方法（Factory Method）是一种创建型设计模式，它提供了一种创建对象的方式，但允许子类决定要实例化的类。这种模式是通过定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类来实现的，从而将对象创建的过程委托给子类

在电商平台的上下文中，我们可以使用工厂方法来创建不同类型的支付方式。例如，我们可能有多种支付方式，如信用卡支付、支付宝支付、微信支付等，每种支付方式都有自己的处理逻辑。

##### 模式UML类图

![customer_payment](./img/customer_payment.png)

##### 模式设计思路

> **PaymentMethodFactory**

该类是工厂模式类，主要用于创建不同的实例化对象，从而使用不同的支付逻辑。这样设计的好处在于可以达到不同支付方法的低耦合，从而便于管理特定支付方式的业务逻辑。

> **PaymentMethod**

该类是支付方式的抽象基类，定义了支付类的支付方法。不同的支付方式进行实例化，重构对应的支付逻辑。

> **CreditCardPayment**

该类具体实现了信用卡支付方式的业务逻辑。

> **AlipayPayment**

该类具体实现了支付宝支付方式的业务逻辑。

> **WechatPayment**

该类具体实现了微信支付方式的业务逻辑。

##### 核心代码

```c++
// PaymentMethod.h
#ifndef PAYMENT_METHOD_H
#define PAYMENT_METHOD_H

#include <iostream>
#include <stdexcept>

// 抽象基类
class PaymentMethod {
public:
    virtual void pay(int amount) = 0; // 纯虚函数
    virtual ~PaymentMethod() {} // 虚析构函数
};

// CreditCardPayment 类声明
class CreditCardPayment : public PaymentMethod {
public:
    void pay(int amount) override;
};

// AlipayPayment 类声明
class AlipayPayment : public PaymentMethod {
public:
    void pay(int amount) override;
};

// WechatPayment 类声明
class WechatPayment : public PaymentMethod {
public:
    void pay(int amount) override;
};

// PaymentMethodFactory 类声明
class PaymentMethodFactory {
public:
    enum PaymentType {
        CREDIT_CARD,
        ALIPAY,
        WXPAY
    };

    static PaymentMethod* createPaymentMethod(PaymentType type);
};

#endif // PAYMENT_METHOD_H

```



##### 代价说明

在电商平台中使用工厂方法（Factory Method）模式来创建不同类型的支付方式（如信用卡支付、电子钱包支付）确实可以提供一定程度的灵活性和封装性，但同时也会带来一些潜在的负面代价，这些包括：

1. **增加代码复杂性**：
   - 实现工厂方法模式通常需要引入额外的类和接口，这可能增加系统的整体复杂度。对于简单的支付方式创建需求，这种额外的复杂性可能是不必要的。
2. **扩展性问题**：
   - 虽然工厂方法模式提供了一定的灵活性，但在添加新的支付方式时，仍然需要修改工厂类，添加新的工厂方法或修改现有的逻辑，这可能违反了开闭原则（对扩展开放，对修改封闭）。
3. **理解和维护成本提升**：
   - 对于新加入项目的开发人员来说，理解工厂模式的工作原理和各个支付方式类之间的关系可能需要一定时间，增加了学习和维护的成本。
4. **过度设计风险**：
   - 如果支付方式不是经常变化或者变化不大，使用工厂方法可能会导致过度设计。在这种情况下，更简单的实现方法可能更为合适。
5. **测试复杂性增加**：
   - 测试工厂方法模式涉及的类可能比直接实例化具体类更为复杂，因为需要验证工厂是否能够正确地创建各种类型的支付方式对象。
6. **性能开销**：
   - 虽然通常不显著，但工厂方法模式可能会引入一些运行时的性能开销，尤其是在频繁创建和销毁支付对象的场景中。
7. **间接性导致的调试难度**：
   - 工厂方法模式的间接性可能在某些情况下使得调试更加困难，特别是当涉及到多层工厂和复杂的创建逻辑时。

#### 状态模式

##### 模式应用场景

在电商平台中，状态（State）模式的应用主要集中在订单处理的不同阶段。订单在其生命周期内会经历多个状态，每个状态代表订单的不同阶段。状态模式允许订单对象在这些不同的状态间平滑转换，同时保持状态特定行为的封装。这种模式提高了代码的可维护性和扩展性，使得新增或修改订单状态变得更加简单。

##### 模式UML类图

![customer_order](./img/customer_order.png)

##### 模式设计思路

> **OrderState**

该类是订单状态抽象基类，其中定义了订单进行状态变更和状态获取的方法。

> **Order**

该类是订单信息的抽象基类，其中定义了一个实际订单中如何进行订单转换和订单状态获取，使用状态模式来管理其在不同阶段的行为。

> **OrderedState**

该类具体定义了处于已下单状态的订单的管理和转换方法。

> **PaidState**

该类具体定义了处于已支付状态的订单的管理和转换方法。

> **ShippedState**

该类具体定义了处于已发货状态的订单的管理和转换方法。

>**CompletedState**

该类具体定义了处于已完成状态的订单的管理和转换方法。

##### 核心代码

```c++
// OrderState.h订单状态类
#ifndef ORDER_STATE_H  // 头文件保护开始
#define ORDER_STATE_H

#include<iostream>
using namespace std;

class Order;

class OrderState {
public:
    virtual ~OrderState() {}

    // 状态管理
    virtual void handleRequest(Order *order) = 0;

    // 获取当前状态的名称
    virtual string getStateName() const = 0;
};

#endif // ORDER_STATE_H  // 头文件保护结束


// Order.h订单类
#include "OrderState.h"

// Order 类，表示一个订单
class Order {
private:
    OrderState *state; // 当前状态

public:
    Order() : state(nullptr) {}
    ~Order() { delete state; }

    // 设置订单的当前状态
    void setState(OrderState *state) {
        delete this->state;
        this->state = state;
    }

    // 转移到下一个状态
    void nextState() {
        if (state) {
            state->handleRequest(this);
        }
    }

    // 获取当前状态的名称
    std::string getStateName() const {
        return state ? state->getStateName() : "No State";
    }
    
};
```

##### 代价说明

在考虑使用状态模式时，重要的是要仔细评估这些潜在的负面影响，并根据具体的应用场景和需求做出决策。在一些情况下，可能需要寻找更简单或更适合的设计模式来处理订单的状态管理。

1. **增加了类的数量**：
   - 状态模式需要为每种可能的状态创建一个新的类。这可能导致类的数量迅速增加，尤其是在状态较多的复杂系统中。
2. **维护成本提高**：
   - 随着状态数量的增加，维护这些状态类的工作也会变得更加繁重。每个状态类都需要维护和更新，尤其是当业务逻辑发生变化时。
3. **复杂性增加**：
   - 对于新加入项目的开发人员来说，理解所有状态及其之间的转换可能比较困难。状态模式可能会引入一定程度的学习曲线。
4. **状态转换逻辑的复杂性**：
   - 在一些复杂的业务场景中，状态之间的转换逻辑可能非常复杂，需要仔细处理状态转换的条件和时机。
5. **测试难度提升**：
   - 测试包含多个状态和状态转换的系统可能更加困难，因为需要覆盖所有可能的状态和转换路径。
6. **过度设计的风险**：
   - 对于某些简单的场景，使用状态模式可能是过度设计。如果系统的状态管理相对简单，使用状态模式可能会引入不必要的复杂性。
7. **依赖性问题**：
   - 状态类可能会依赖于订单类的内部实现，这可能导致紧耦合，使得系统的某些部分难以独立变更或重用

#### 原型模式

##### 模式应用场景

原型（Prototype）模式在软件开发中通常用于创建对象的副本。在您提到的应用场景中——快速复制或克隆用户的偏好设置和购物车内容——原型模式可以有效地实现对象的复制功能，同时避免了直接使用构造函数创建新实例时可能涉及的复杂性和资源消耗。

##### 模式UML类图

![customer_prototype](./img/customer_prototype.png)

##### 模式设计思路

> **ICloneable**

该类是原型接口类，用于定义克隆方法，其他具体实例可以实现对应的接口，来实现资源复制的功能。

> **Preferences**

该类定义了用户偏好设置，实现了原型接口的具体业务逻辑

> **ShoppingCart**

该类定义了购物车内容，实现了原型接口的具体业务逻辑

##### 核心代码

```c++
// ICloneable.h
#ifndef ICLONEABLE_H
#define ICLONEABLE_H

// 原型接口类
class ICloneable {
public:
    virtual ~ICloneable() {}

    // 纯虚函数，用于克隆对象
    virtual ICloneable* clone() const = 0;
};

#endif // ICLONEABLE_H

// Preferences.h
#ifndef PREFERENCES_H
#define PREFERENCES_H

#include "ICloneable.h"
#include <vector>
#include <string>
#include<iostream>
using namespace std;

// 用户偏好设置类
class Preferences : public ICloneable {
private:
    vector<string> settings; // 存储用户偏好设置

public:
    Preferences();
    Preferences(const vector<string>& settings);

    // 实现 ICloneable 接口的克隆方法
    ICloneable* clone() const override;

    // 打印偏好设置的方法
    void printPreferences() const;
};

#endif // PREFERENCES_H

// ShoppingCart.h
#ifndef SHOPPINGCART_H
#define SHOPPINGCART_H

#include "ICloneable.h"
#include <vector>
#include <string>
#include<iostream>
using namespace std;

// 购物车类
class ShoppingCart : public ICloneable {
private:
    vector<string> items; // 存储购物车中的商品

public:
    ShoppingCart();
    ShoppingCart(const vector<string>& items);

    // 实现 ICloneable 接口的克隆方法
    ICloneable* clone() const override;

    // 打印购物车内容的方法
    void printShoppingCart() const;
};

#endif // SHOPPINGCART_H

```



##### 代价说明

针对场景——在电商平台的顾客子系统中使用原型模式来快速复制或克隆用户的偏好设置和购物车内容，以下是更具体的负面代价分析：

1. **数据一致性问题**：
   - 当用户的偏好设置或购物车内容被克隆后，如果原始数据发生变化（比如价格更新、库存变动），克隆出的副本不会同步更新，可能导致用户看到的信息过时或错误。

2. **深拷贝的复杂性**：
   - 用户偏好设置和购物车可能包含多层嵌套的对象（如商品详情、折扣信息等）。实现这些对象的深拷贝可能既复杂又耗时，特别是当它们包含循环引用或共享资源时。

3. **性能开销**：
   - 如果购物车或偏好设置包含大量数据，克隆操作可能会消耗显著的计算资源和时间，尤其是在高流量的电商平台上。

4. **隐私和安全性考虑**：
   - 克隆包含个人信息的偏好设置和购物车内容时，需要小心处理以防泄露用户数据。不当的克隆实现可能导致敏感信息的未授权访问。

5. **维护和更新挑战**：
   - 如果电商平台的数据结构或业务逻辑发生变化，可能需要相应地更新克隆逻辑。这可能增加代码的维护难度和成本。

6. **过度使用原型模式的风险**：
   - 在某些情况下，直接创建新实例而非克隆可能更简单、更直观。过度使用原型模式可能导致不必要的复杂性，尤其是在不需要频繁创建相似对象的场景中。

7. **错误处理的复杂性**：
   - 克隆过程中可能发生的错误（如内存分配失败）需要被妥善处理，否则可能导致程序异常或崩溃。

## 店铺子系统

## 商品子系统

## 活动与广告子系统

## 订单子系统
