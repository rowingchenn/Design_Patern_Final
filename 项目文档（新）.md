# 软件设计模式期末项目文档

## 课程情况
2023 Fall 史扬 周三下午 9-11 节
## 组员
 张唯琛 2151414

## 项目概要

本项目由6个子系统组成，每个子系统由3个模块组成
1. 子系统功能概述
2. 子系统总 UML 类图
3. 设计模式
    1. A 设计模式
        1. 模式应用场景【说明这个模式在本子系统中实现怎样的作用】
        2. 该设计模式的 UML 类图
        3. 说明各个类的作用以及设计思路【格式不限】
        4. 贴代码
        5. 代价说明（使用此设计模式的负面代价）
   1. B 设计模式

## 全局命令子系统-lrk

### 功能概述

### UML 类图

### 设计模式
#### 模块模式
##### 模式应用场景
##### 模式UML类图
##### 模式设计思路
##### 核心代码
##### 代价说明


## 顾客子系统

## 店铺子系统

## 商品子系统

## 活动与广告子系统

## 订单子系统

### 1.订单子系统功能概述

1. 创建订单：该系统允许用户创建新的订单。在代码中没有直接提供创建订单的方法，但可以假设系统提供了相应的功能。
2. 支付订单：用户可以支付订单，将订单状态从未支付状态切换为已支付状态。在代码中，`Order` 类中的 `pay` 函数实现了这一功能。
3. 取消订单：用户可以取消未支付的订单。在代码中没有直接提供取消订单的方法，但可以假设系统提供了相应的功能。
4. 显示订单信息：系统可以显示订单的详细信息，包括订单号、顾客姓名、订单金额和订单状态等。在代码中，`OrderInterface` 类的 `display` 函数用于显示订单信息。
5. 处理不同状态的订单：根据订单的不同状态，系统可以执行相应的业务逻辑。在代码中，不同的订单状态由 `State` 类及其派生类（如 `ConcreteStateA` 和 `ConcreteStateB`）表示，并通过调用 `Handle` 函数来处理相应的状态。
6. 状态切换逻辑：系统可以根据用户的操作或其他条件，自动地将订单从一个状态切换到另一个状态。在代码中，`Order` 类的 `pay` 函数中通过改变 `m_pState` 的指向来实现状态的切换。

### 2.订单子系统UML类图

![](img\Order.png)

### 3.设计模式

#### 1.装饰器模式

##### 1.模式应用场景

​		在该订单系统中，状态模式实现了订单的状态管理和状态转换功能。具体而言，以下是状态模式在该系统中的功能：

1. 订单状态的管理：通过状态模式，每个订单对象都具有一个与之对应的状态对象，用于表示订单的当前状态。订单状态的管理由 `Order` 类中的 `m_pState` 成员变量负责，它指向当前订单的状态对象。这样，系统可以轻松地跟踪和管理订单的状态。
2. 订单状态的转换：订单在不同的状态之间进行转换，例如从未支付状态（`ConcreteStateA`）转换为已支付状态（`ConcreteStateB`）。这种转换由 `Order` 类中的 `pay` 函数实现，其中通过改变 `m_pState` 的指向，将订单的状态从当前状态切换为新的状态。通过状态模式，订单的状态转换变得简单和灵活。
3. 根据订单状态执行不同的行为：每个状态类（如 `ConcreteStateA` 和 `ConcreteStateB`）都实现了 `Handle` 函数，在函数中打印相应的订单状态信息。通过 `Order` 类中的 `Request` 函数，可以根据订单的当前状态调用相应状态对象的 `Handle` 方法，从而执行不同的行为。这样，系统可以根据订单的状态自动选择正确的行为，避免了繁琐的条件语句。

##### 2.UML类图

![](img\Order-State.png)

##### 3.设计思路

1. 将状态抽象为类：者通过创建一个抽象的状态类（`State`），用于定义订单可能的状态以及状态之间的共同行为。这个抽象类可以包含一些通用的方法或属性，以便被具体的状态类继承和实现。
2. 实现具体的状态类：针对订单系统中可能的具体状态，创建了具体的状态类（如`ConcreteStateA`和`ConcreteStateB`）。每个具体状态类都继承自抽象状态类，并实现了自身特定的行为逻辑。
3. 在订单类中引入状态对象：订单类（`Order`）持有一个指向当前状态的状态对象的引用（`m_pState`）。这样，订单对象可以根据当前状态来执行相应的行为，而无需通过复杂的条件语句进行判断。
4. 状态切换的实现：订单对象通过特定的方法（如`pay`）触发状态的切换。在状态切换时，订单对象将自身的状态引用指向新的状态对象，从而实现状态的切换。
5. 状态对象的行为处理：每个具体状态类都实现了抽象状态类中定义的方法，用于处理订单在特定状态下的行为。订单类通过委托当前状态对象来执行相应的行为逻辑，实现了状态与行为的解耦。

##### 4.相关代码

`class State//设计模式: state`
`{`
`public:`

    virtual int value() = 0;//状态标志位
    
    virtual void Handle(Order *pOrder) = 0;//打印状态函数

`};`

`class ConcreteStateA : public State { //未支付状态`
`public:`
    `int value() { return 1; }`

    void Handle(Order *pOrder) { cout << "未支付" << endl; }

`};`

`class ConcreteStateB : public State { //已支付状态`
`public:`
    `int value() { return 2; }`

    void Handle(Order *pOrder) { cout << "已支付" << endl; }

`};`

`class Order { //订单类`
`private:`
    `string orderid;//订单id`
    `int amount; //订单数量`
    `map<CommodityInformation *, int> items;//订单内容`
    `float Price = 0.0f; //订单价格`
    `State *m_pState; //订单状态的指针`
    `int Customerid; //用户id`
`public:`
    `Order(int customerID, map<CommodityInformation *, int> Items, float price);//构造函数`

```
int getAmount() const { return amount; }//获得当前订单数量

const map<CommodityInformation *, int> &getItems() const { return items; }//获得当前订单内容

string getID() const { return orderid; }//获得当前订单id

int getcustomerid() { return Customerid; }//获得该订单的用户id

void Request();//订单状态

int getPayState() { return m_pState->value(); }

void pay();//支付
```

`};`



`//支付，实际上就是修改订单状态`
`void Order::pay()`
`{`
    `//如果是未支付`
    `if (m_pState->value() == 1) {`
        `State* pStateB = new ConcreteStateB();`
        `m_pState = pStateB;`
        `cout << "成功支付" << endl;`
        `//如果已支付，提示勿重复支付`
    `}`
    `else {`
        `cout << "已成功支付，请勿重复支付。";`
    `}`
`}`



##### 5.代价说明

1. 增加类的数量：引入状态模式会增加额外的类，包括抽象状态类和具体状态类。这可能会增加系统中的类数量，增加代码的复杂性和理解难度。
2. 增加复杂性：状态模式需要在订单类中维护状态对象的引用，并在状态转换时更新状态对象。这可能会增加代码的复杂性，需要更多的代码和逻辑来管理状态和状态之间的转换。
3. 状态转换的管理：状态模式需要明确定义状态之间的转换条件和逻辑。如果订单系统中的状态转换较为复杂或存在大量的状态组合，可能需要额外的管理机制来确保正确的状态转换。
4. 额外的开销：状态模式中的状态对象需要在运行时动态创建和切换，这可能会引入一定的性能开销和内存消耗。如果订单系统中的状态转换频繁且性能要求较高，需要仔细评估状态模式的使用。
5. 上下文依赖关系：使用状态模式时，状态对象可能需要访问订单类的其他属性或方法。这种依赖关系可能导致状态对象与订单类之间的耦合增加，需要谨慎设计和处理。