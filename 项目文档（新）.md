# 软件设计模式期末项目文档

## 课程情况
2023 Fall 史扬 周三下午 9-11 节
## 组员
 张唯琛 2151414

## 项目概要

本项目由6个子系统组成，每个子系统由3个模块组成
1. 子系统功能概述
2. 子系统总 UML 类图
3. 设计模式
    1. A 设计模式
        1. 模式应用场景【说明这个模式在本子系统中实现怎样的作用】
        2. 该设计模式的 UML 类图
        3. 说明各个类的作用以及设计思路【格式不限】
        4. 贴代码
        5. 代价说明（使用此设计模式的负面代价）
   1. B 设计模式

## 全局命令子系统-lrk

### 功能概述

### UML 类图

### 设计模式
#### 模块模式
##### 模式应用场景
##### 模式UML类图
##### 模式设计思路
##### 核心代码
##### 代价说明


## 顾客子系统

## 店铺子系统

## 商品子系统

## 活动与广告子系统

####	功能与实现

##### 广告子系统

+ 主要功能：

  1. 添加广告
  2. 浏览广告

+ 实现方案：

  1. 结构体AdNode代表的变量类型用于存储一个广告的具体内容，包括广告ID以及广告内容。

     ```cpp
     struct AdNode//广告
     {
         int AdID;
         string Content;
     
         AdNode(int ID, string Cont)
         {
             AdID = ID;
             Content = Cont;
         }
     };
     ```

     

  2. AdvertisingSystem类用于对所有当前存在的广告进行管理，是广告系统的主体，通过开放Accept函数使用Visitor模式进行功能实现与扩展。为了保持广告系统的唯一性，使用了单例模式。

     ```cpp
     class AdvertisingSystem//广告子系统（单例）
     {
     public:
         ~AdvertisingSystem();
     
         static AdvertisingSystem* GetAdSystemInstance();
     
         void Accept(AdVisitor* Visitor);
     
         void PrintAd(int Index);//打印广告
     
     private:
     
         AdvertisingSystem();
     
         static AdvertisingSystem* AdSystemInstance;
     
         vector<AdNode*> AdvertisingList;
     };
     ```

  3. AdVisitor类作为AdvertisingSystem的访问者，用于实现与扩展广告系统的功能，并保持AdvertisingSystem类的简洁性。AdVisitor_Browse类与AdVisitor_Add类均继承于AdVisitor类，分别实现了广告系统的浏览功能和添加功能。

     ```cpp
     class AdVisitor//广告visitor父类
     {
     public:
     
         virtual ~AdVisitor() = default;
     
         virtual void Visit(AdvertisingSystem* AdSystem) = 0;
     };
     class AdVisitor_Browse : public AdVisitor//浏览广告visitor子类
     class AdVisitor_Add : public AdVisitor//添加广告visitor子类
     ```

##### 活动子系统

+ 主要功能：

  1. 添加活动
  2. 浏览活动
  3. 计算活动价格并选择最优方案
  4. 根据商品推荐相关活动

+ 实现方案：

  1. AcNode类是单个活动的基类，用于存储所有活动都拥有的内容，包括活动ID以及活动内容。

     ```cpp
     class AcNode//活动父类
     {
     public:
     
         AcNode(int ID, string Cont);//两类活动id不可相同
         
         int AcID;
         string Content;
     };
     ```

     从AcNode类派生出两个子类：AcNode_Discount、AcNode_FullReduction，分别代表打折类活动和满减类活动。

     AcNode_Discount中存储了打折商品列表以及打折力度这两个关键属性，AcNode_FullReduction中存储了满减的阈值以及力度这两个关键属性。

     通过这些关键属性便可以提供：1.是否能使用该活动；2.使用该活动的价格为多少，这两个函数，进一步便可以提供完整的“ ExecuteActivity”这个函数用于获取通过该活动的价格。

     ```cpp
     class AcNode_Discount : public AcNode//打折类活动子类
     {
     public:
     
         AcNode_Discount(int ID, string Cont, vector<int>& CommodityInformationIDList, float DisRate);
         
         float ExecuteActivity(CommodityInformation* BuyCommodityInformation, int Amount); // 若商品打折，则返回商品打完折的价格，否则返回原价
     
         bool IsSatisfy(CommodityInformation* BuyCommodityInformation);//判断商品是否打折
     
     private:
     
         float CalPrice(CommodityInformation* BuyCommodityInformation, int Amount);//返回商品打完折后的价格
     
         vector<int> SatisfyCommodityInformationIDList;
     
         float DiscountRate;
     };
     
     class AcNode_FullReduction : public AcNode//满减类活动子类
     {
     public:
     
         AcNode_FullReduction(int ID, string Cont, float Thd, float RedAmount);
     
         float ExecuteActivity(map<CommodityInformation*, int>& BuyCommodityInformation); //若商品达到满减金额，则返回商品满减后的价格，否则返回原价
     
     private:
     
         bool IsSatisfy(map<CommodityInformation*, int>& BuyCommodityInformation);//判断商品是否满减
     
         float CalPrice(map<CommodityInformation*, int>& BuyCommodityInformation);//返回商品满减后的价格
     
         float Threshold;
         float ReductionAmount;
     };
     ```

  2. ActivitySystem类用于管理当前存在的活动，通过开放Accept函数使用Visitor模式进行功能实现与扩展。为了保持活动系统的唯一性，使用了单例模式。因为存在两种活动，为了处理起来更加高效，使用了两个vector分别对其进行存储。

     ```cpp
     class ActivitySystem//活动子系统
     {
     public:
         ~ActivitySystem();
     
         static ActivitySystem* GetAcSystemInstance();
     
         void Accept(AcVisitor* Visitor);
     
         void PrintAc_D(int Index);//打印打折类活动
         void PrintAc_F(int Index);//打印满减类活动
     
     private:
     
         ActivitySystem();
     
         static ActivitySystem* AcSystemInstance;
     
         vector<AcNode_Discount*> DiscountActivityList;
         vector<AcNode_FullReduction*> FullReductionActivityList;
     };
     ```

  3. AcVisitor类作为ActivitySystem的访问者类，用于实现与扩展活动系统的功能，并保持ActivitySystem类的简洁性。

     ```cpp
     class AcVisitor//活动Visitor父类
     {
     public:
         virtual ~AcVisitor() = default;
         virtual void Visit(ActivitySystem* AcSystem) = 0;
     };
     ```

     为了实现添加活动功能，派生出了AcVisitor_Add类：

     ```cpp
     class AcVisitor_Add : public AcVisitor//添加活动Visitor子类
     ```

     为了实现浏览活动功能，派生出了AcVisitor_Browse类：

     ```cpp
     class AcVisitor_Browse : public AcVisitor//浏览活动Visitor子类
     ```

     为了实现推荐活动功能，派生出了AcVisitor_Recommend类：

     ```cpp
     class AcVisitor_Recommend : public AcVisitor//推荐活动Visitor子类
     ```

     为了实现计算最优价格功能，派生出了AcVisitor_CalPrice类，因为存在两种活动方式（打折、满减），且两种活动计算价格的方法以及输入都不一样，故需要分开处理，所以再从AcVisitor_CalPrice类派生出AcVisitor_CP_Discount类和AcVisitor_CP_FullRedu类分别用于计算打折类活动价格和满减类价格：

     ```cpp
     class AcVisitor_CalPrice : public AcVisitor//计算最优活动Visitor子类
     class AcVisitor_CP_Discount : public AcVisitor_CalPrice//计算最优打折活动Visitor子类
     class AcVisitor_CP_FullRedu : public AcVisitor_CalPrice//计算最优满减活动Visitor子类
     ```

  4. Interpreter类用于解释活动方案并打印输出，在计算最优价格以及推荐活动这两个函数中都会涉及到对一些活动进行组织并给予显示，通过一个解释器使得这种组织更加方便和准确：

     ```cpp
     class Interpreter
     {
     public:
     
         Interpreter();
     
         void MakeInterpretation(string Code);//解释Code含义
     
     private:
         
         ActivitySystem* AcSystemInstance;
     };
     ```

#### UML类图

##### 广告子系统

![image-20231228091204718](D:\FormyVS\Design_Patern_Final-dev\img\广告子系统类图_tyx.png)

##### 活动子系统

![image-20231228091225646](D:\FormyVS\Design_Patern_Final-dev\img\活动子系统_tyx.png)

#### 设计模式

##### 解释器模式

###### 设计模式实现

在计算最优价格时没有直接打印出最优价格方案，而是构造了一个表达最优活动方案的字符串DecisionCode，需要输出时再交给解释器进行解释输出。

```cpp
void AcVisitor_CP_Discount::Visit(ActivitySystem* AcSystem)
{
    string DecisionCode;
    DecisionCode.push_back('1'); // 1代表需要解释的Code为最优活动列表
    DecisionCode.push_back('1'); // 1代表所选方案为打折活动类
	……
    for (auto BuyCommodityInformation : SaveBuyCommodityInformationMap)
    {
        DecisionCode.push_back(120); // 后续位均代表对应的活动的下标，120即为不使用活动
        ……
        for (int i = 0; i < AcSystem->DiscountActivityList.size(); i++)
        {
            float CalPrice = ……
            if (CalPrice < MinPrice)
            {
                MinPrice = CalPrice;
                DecisionCode[DecisionCode.length() - 1] =static_cast<char>(i); // 对应位置存储对应活动下标
            }
        }
        TotalMinPrice += MinPrice;
    }

    OptimalPrice = TotalMinPrice;
    OptimalDecisionCode = DecisionCode;
}
void AcVisitor_CP_FullRedu::Visit(ActivitySystem* AcSystem)
{
    string DecisionCode;
    DecisionCode.push_back('1'); // 1代表需要解释的Code为最优活动列表
    DecisionCode.push_back('2'); // 2代表所选方案为满减活动类
	……
}
```

同样，在推荐活动是也没有直接打印所有推荐的活动，而是构建了一个表达推荐活动方案的字符串RecommendCode，需要输出时再交给解释器进行解释输出。

```cpp
void AcVisitor_Recommend::Visit(ActivitySystem* AcSystem)
{
    string RecommendCode;
    RecommendCode.push_back('2'); // 2代表需要解释的Code为推荐活动列表
    RecommendCode.push_back('-1'); // 与最优活动编码对齐

    set<int> RecommendAcSet;

    ……

    for (auto Elem : RecommendAcSet)
    {
        RecommendCode.push_back(static_cast<char>(Elem)); // 每一位均存储一个相关的活动的下标
    }

    RecommendActivityCode = RecommendCode;
}
```

解释器接受一个字符串输入进行解释，解释规则与编码规则一一对应：

```cpp
void Interpreter::MakeInterpretation(string Code)
{
    if (Code.length() < 2) // 长度小于2即是一个错误编码，正常编码位数均在两位以上
        return;

    if (Code[0] == '1') // 第一位为1代表需要解释的Code为最优活动方案
    {
        if (Code[1] == '1') // 第二位为1代表选择的活动类别为打折类活动
        {
            cout << "最优活动类别为打折类，具体配置如下：" << endl;
            for (int i = 2; i < Code.length(); i++)
            {
                if (Code[i] == 120) // 编码为120代表不使用活动或没有活动满足
                {
                    cout << "###第" << i-1 << "件商品不活动" << endl;
                    continue;
                }
                cout << "###第" << i-1 << "件商品使用活动为：" << endl;
                AcSystemInstance->PrintAc_D(Code[i]); // 寻找对应的活动进行展示
            }
        }
        else if (Code[1] == '2') // 第二位为2代表选择的活动类别为满减类活动
        {
        	……
        }

    }
    else if (Code[0] == '2') // 第一位为2代表需要解释的Code为推荐活动方案
    {
        cout << "推荐活动为：" << endl;

        for (int i = 2; i < Code.length(); i++)
        {
            AcSystemInstance->PrintAc_D(Code[i]); // 对Code里的每一位代表的活动进行显示
        }
    }
}
```

###### UML类图

![image](https://user-images.githubusercontent.com/54826495/139690611-b0aac152-bc61-47bd-a719-9d67a454c921.png)

###### 代价分析

1. 维护成本

   - **扩展困难**：如果需要新增活动类型或修改活动规则，可能需要对编码规则进行相应的调整，这意味着需要修改`Visit`方法中的编码逻辑以及`Interpreter`中的解释逻辑。

   - **复杂性增加**：随着系统的增长，编码和解释的逻辑可能会变得越来越复杂，这会增加维护的难度。

2. 性能开销
   - **运行时开销**：解释器在运行时需要对编码进行解释，这个过程可能会导致一定的性能开销，特别是当编码非常长或者解释规则很复杂时。

##### 访问者模式

###### 设计模式实现

访问者的定义（源于GoF《Design Pattern》）是：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。
我们在设计 **广告与活动子系统** 时，不确定后续需要进行哪些操作，又不想在后续再修改原来类的代码，所以使用了 **访问者** 设计模式。
以 **广告子系统AdSystem** 为例，我们将说明 **访问者** 设计模式的实现：

1、在 **广告子系统AdSystem** 中写入 **Accept** 函数，用于获得 **访问者**：

```
class AdvertisingSystem
{
public:
    void Accept(AdVisitor* Visitor);
    ……
private:
    ……
};
```

**Accept** 函数的实现方法是：调用传入的 **访问者** 的 **Visit** 函数，将当前类实例传给 **访问者** 。

```
void AdvertisingSystem::Accept(AdVisitor *Visitor) {
    Visitor->Visit(this);
}
```

2、创建 **访问者** 的父类： **Visit** 函数表示要进行的具体操作，这里是纯虚函数，具体操作要在子类实现。

```
class AdVisitor//广告visitor父类
{
public:
    virtual ~AdVisitor() = default;
    virtual void Visit(AdvertisingSystem* AdSystem) = 0;
};
```

3、为每一个操作创建一个 **访问者** 的子类，以 **添加广告** 为例：
相较于 **访问者** 的父类，子类可以添加私有成员变量，如这里的 **广告编号AdID** 、**广告内容Content**；

```
class AdVisitor_Add : public AdVisitor
{
public:
    AdVisitor_Add(int ID, string Cont);
    void Visit(AdvertisingSystem* AdSystem) override;
private:
    int AdID;
    string Content;
};
```

子类需要自己的构造函数：如这里 **添加广告** 访问者子类的构造函数需要将参数传入：

```
AdVisitor_Add::AdVisitor_Add(int ID, string Cont)
{
    AdID = ID;
    Content = Cont;
}
```

**访问者子类** 的代表的具体操作将在 **Visit** 函数里实现：例如这里 **添加广告** 访问者子类的 **Visit** 函数实现如下：

```
void AdVisitor_Add::Visit(AdvertisingSystem* AdSystem)
{
    if (AdID < 0) // 验证广告编号合法性
    {
        cout << "ID < 0 !!!" << endl;
        return;
    }
    AdNode* ad = new AdNode(AdID, Content); // 创建广告实例
    AdSystem->AdvertisingList.push_back(ad); // 将广告加到广告集合
}
```

###### UML类图

![image](https://user-images.githubusercontent.com/54826495/139690681-20ab3e9a-b86a-49fb-813b-f1fcda9aabc1.png)

###### 代价分析

1. **增加复杂性**: 访问者模式引入了新的抽象层次和间接性，可能使系统更加复杂，特别是对于不熟悉该模式的开发者而言。
2. **不适用于频繁变化的对象结构**: 如果对象结构经常发生变化，每次变化都可能需要更新所有的访问者类，这会降低模式的有效性。
3. **性能开销**: 访问者模式需要动态分派（如虚函数调用），这可能导致比直接实现操作更多的运行时开销。

##### 策略模式

###### 设计模式实现

策略模式用于实现一个行为有多种选择的情况，并且将每种选择需要做的操作封装起来，方便调用。
我们这里在 **活动子系统** 的 **访问者AcVisitor** 中使用了策略模式，是为了更方便的区别使用 **打折类活动** 与 **满减类活动** 。
具体来说，我们需要找出购买一系列商品时，通过各种活动优惠后，最优的价格，在这里，我们有两种策略：一是参与 **打折类活动** ，二是参与 **满减类活动** ，然后对比两者谁更优惠。
在使用 **策略模式** 时，我们首先创建了指向所有策略的父类 **AcVisitor_CalPrice** 的指针，这个指针既可以指向 **打折策略类AcVisitor_CP_Discount** ，又可以指向 **满减策略类AcVisitor_CP_FullRedu** 。

```
float Facade::CalOptimalDecision(map<CommodityInformation*, int>& BuyCommodityInformationMap)
{
    AcVisitor_CalPrice* CalPriceVisitor;// 指向所有策略的父类
    
    CalPriceVisitor = new AcVisitor_CP_Discount(BuyCommodityInformationMap);// 策略1，使用打折活动
    AcSystemInstance->Accept(CalPriceVisitor);
    ……
    delete CalPriceVisitor;

    CalPriceVisitor = new AcVisitor_CP_FullRedu(BuyCommodityInformationMap);// 策略2，使用满减活动
    AcSystemInstance->Accept(CalPriceVisitor);
    ……
}
```

###### UML类图

![image](https://user-images.githubusercontent.com/54826495/139690727-d2648115-6d0d-449e-b1e0-7c1e1b780c69.png)

###### 代价分析

1. **增加类的数量**：每种策略都需要一个单独的类。随着策略数量的增加，系统中的类的数量也会增加，可能导致管理上的复杂性。
2. **客户端必须了解不同策略**：使用策略模式的客户端需要了解每种策略的差异，以便做出合适的选择。这可能增加了使用类库的难度。
3. **运行时开销**：策略模式可能会引入一些运行时开销，因为策略通常通过接口或抽象类实现，这可能涉及到动态绑定。
4. **对象生命周期管理**：策略对象的创建和销毁需要管理，特别是在使用动态分配（如`new`和`delete`）时。不当的资源管理可能导致内存泄漏或其他资源问题。


##### 外观模式

###### 设计模式实现

外观模式的意义在于，为几个子系统的对外接口提供一个统一的界面，使子系统更容易使用。
这里我们给予 **广告子系统AdvertisingSystem** 与 **活动子系统ActivitySystem**  一个外观：

```
class Facade//外观模式
{
public:

    Facade();//构造广告子系统、活动子系统、解释器

    // 广告操作：
    
    void BrowseAd();//浏览全部广告
    void BrowseAd(int BrowseAdID);//浏览单个广告
    void AddAd(int ID, string Cont);//添加单个广告

    // 活动操作：
    
    void BrowseAc();//浏览全部活动
    void BrowseAc(int BrowseAcID);//浏览单个活动
    void AddAcD(int ID, string Cont, vector<int>& CommodityInformationReaderList, float DisRate);
    //添加打折类活动
    void AddAcF(int ID, string Cont, float Thd, float RedAmount);
    //添加满减类活动
    float CalOptimalDecision(map<CommodityInformation*, int>& BuyCommodityInformationReaderMap);
    //寻求最优惠价格，并打印此时活动列表
    void RecommendActivity(vector<CommodityInformation*>& RelatedCommodityInformationReaderList);
    //打印与商品相关的所有活动
    void RecommendActivity(map<CommodityInformation*, int>& RelatedCommodityInformationReaderMap);
    //打印与商品相关的所有活动

private:
    AdvertisingSystem* AdSystemInstance;
    ActivitySystem* AcSystemInstance;
    Interpreter* ActivityInterpreter;
};
```

在外观构造函数中，我们生成了两个子系统与解释器的实例，并给它们添加了一系列初始化广告、活动内容；

```
Facade::Facade()
{
    AdSystemInstance = AdvertisingSystem::GetAdSystemInstance();// 广告子系统
    AcSystemInstance = ActivitySystem::GetAcSystemInstance();// 活动子系统
    ActivityInterpreter = new Interpreter();// 解释器

    AddAd(1, "双11开门红不熬夜！每日干果限量低价放送！");//添加广告
    ……
}
```

另外还定义了一系列其他子系统需要调用的接口，例如，**浏览所有广告** 操作，原本需要生成观察者 、Accept观察者、释放观察者三步操作，现在封装成一个函数 **BrowseAd** ，更加方便：

```
void Facade::BrowseAd()
{
    AdVisitor_Browse* AdBrowse = new AdVisitor_Browse();
    AdSystemInstance->Accept(AdBrowse);
    delete AdBrowse;
}
```

###### UML类图

![image](https://user-images.githubusercontent.com/54826495/139690809-f1141966-01b9-4a76-9dca-2476b1557431.png)

###### 代价分析

1. **可能产生单点故障**：所有的子系统操作都通过外观类进行，如果外观类出现问题，可能影响整个系统的可用性。
2. **可能限制功能**：尽管外观提供了简化的接口，但有时可能会隐藏子系统中的一些功能，使得高级用户无法利用这些功能。
3. **性能考虑**：如果外观类仅仅是将调用转发到子系统而没有额外的逻辑处理，可能会引入额外的性能开销，尤其是在高性能要求的环境中。

## 订单子系统