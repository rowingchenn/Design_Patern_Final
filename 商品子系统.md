商品子系统

1. 子系统功能概述：

1. 显示商品信息
2. 售卖商品
3. 将商品加入（移出）组合

1. 子系统总UML类图：

1. 设计模式：

1. Flyweight设计模式

1. 模式应用场景

工厂在生成对象的时候优先检查哈希表内是否存在该对象，有的话直接调用该对象，没有的话再重新生成，可以大大减少内存的使用，提高运行效率

1. 类图

![](RackMultipart20231229-1-56770p_html_5ca90e98bd3ae105.png)

1. 设计思路

Flyweight模式通过使用工厂类CommodityFactory 来创建商品对象，同时维护一个哈希表\_existingCommodityList 以存储已经创建过的商品对象。

1. 代码展示

![](RackMultipart20231229-1-56770p_html_101fb3a367e6b2d9.png)

1. 代价说明

Flyweight设计模式的使用带来了一些潜在的负面代价。引入共享对象池可能增加代码的复杂性，引入性能开销，特别是在多线程环境下需要考虑同步问题。不适用于所有情况，可能导致全局状态，使得代码难以理解和调试。

1. Bridge桥接模式

1. 模式应用场景

在商品子系统中，获得商品信息的功能使用了桥接模式，使得商品类的具体实现与其抽象功能分离，二者可以互不干扰地独立变化。

1. 类图

![](RackMultipart20231229-1-56770p_html_c8363d175b6e7d68.png)

1. 设计思路

CommodityInformation是商品信息的具体实现基类，包含基本的商品属性如商品名称和商品ID等。SingleCommodity是商品信息基类的一种具体实现，代表普通的单品商品，具有独特属性amount表示库存数量。CompositeCommodity是另一种商品信息基类的实现，表示复合商品，其独特属性commodity\_list用于存储包含的其他商品。

CommodityInformationReader是获取商品属性的抽象基类，定义了基本的方法函数，如获取商品名称、获取商品价格等。CommodityInformationVipReader继承于这个基类，专为VIP用户设计，其getPrice()方法返回商品原价的八折。这体现了对抽象功能的不同实现，以满足VIP用户的特殊需求。

1. 代码展示

![](RackMultipart20231229-1-56770p_html_1c0da4505fc6277b.png)

1. 代价说明

引入桥接模式通常涉及更多的类和对象，导致系统整体复杂性增加。需要同时管理抽象部分和实现部分，这可能增加了代码的理解和维护难度。在设计时，需要仔细权衡如何划分抽象和实现，避免过度划分导致过多的类和层次结构，从而提高设计的抽象程度。此外，桥接模式的引入可能需要更多的开发工作，并在一定程度上增加了系统的开发成本。

1. Composite 组合模式

1. 模式应用场景

组合模式用于把一组相似的对象当作一个单一的对象，依据树形结构来组合对象，用来表示部分以及整体层次。

在本项目中，把单一商品类和组合商品类组合成为商品基类。

1. 类图

![](RackMultipart20231229-1-56770p_html_caede2b9714e2127.png)

1. 设计思路

CommodityInformation作为商品的基类，衍生出了两个具体的子类：SingleCommodity表示单一商品，而CompositeCommodity表示组合商品。SingleCommodity具有特有属性amount，用于表示商品的库存数量。相反，CompositeCommodity具有特有属性commodity\_list，用于存储指向商品基类的指针，实现了商品的组合。

CommodityInformation既是所有商品的共同接口，提供了统一的方式来访问商品的信息，同时它也作为聚合的对象存在于CompositeCommodity类的属性中。这样的设计体现了组合模式，允许将单一商品和组合商品一视同仁地对待，使得客户端可以一致地处理单一商品和组合商品，从而提高了系统的灵活性和可扩展性。

1. 代码展示

classSingleCommodity : publicCommodityInformation { // 设计模式: composite, 桥接模式

protected:

    intamount; // 商品库存数量
    
    virtualboolHasCommodity(CommodityInformation\*commodity);

public:

    SingleCommodity(intID, stringname, floatprice,intshopID, intamount);
    
    virtualboolEnough(intamount);
    
    virtualboolSell(intamount);
    
    virtualvoidDisplay();

};

classCompositeCommodity : publicCommodityInformation { // 设计模式: composite

protected:

    list\<CommodityInformation\*\>commodity\_list;
    
    virtualboolHasCommodity(CommodityInformation\*commodity);

public:

    CompositeCommodity(intID, stringname, floatprice, intshopID);
    
    boolAdd(CommodityInformation\*commodity);
    
    boolRemove(CommodityInformation\*commodity);
    
    virtualboolEnough(intamount);
    
    virtualboolSell(intamount);
    
    virtualvoidDisplay();
    
    // 用于Iterator
    
    list\<CommodityInformation\*\>\*GetCommodityList() { return&commodity\_list; };
    
    CompositeCommodityIterator&begin() {
    
        CompositeCommodityIterator\*iter=newCompositeCommodityIterator(commodity\_list.begin());
    
        return\*iter;
    
    }
    
    CompositeCommodityIterator&end() {
    
        CompositeCommodityIterator\*iter=newCompositeCommodityIterator(commodity\_list.end());
    
        return\*iter;
    
    }
    
    intsize() { returncommodity\_list.size(); }

};

1. 代价分析

引入组合模式通常涉及更多的类和对象，可能增加了系统整体的复杂性，使得代码的理解和维护变得更为复杂。其次，为了支持组合模式，可能需要引入许多额外的类和接口，这可能会增加开发工作量和代码的量。此外，组合模式虽然提供了一致的处理方式，但在一些情况下也可能引入一致性的挑战，因为对于不同类型的商品可能需要不同的处理逻辑。

1. Command 命令模式

1. 模式应用场景

用于具体商品的售卖，Command和CommoditySale通过组合关系形成了一个命令模式，之后调用其中的execute()函数实现具体的售卖行为。

1. 类图

![](RackMultipart20231229-1-56770p_html_d065f01f4fcfa1ab.png)

1. 设计思路

Command是一个命令的虚基类，其中定义了一个execute()纯虚函数。CommoditySale类是具体的命令类，用于卖出一定数量的某个商品。它承继并实现了Command类，并且关联了CommodityInformation类，表示这个命令类控制的具体商品。

在复合商品的售卖流程中，CommoditySale命令类调用了CommodityInformation商品基类的虚函数Sell()。这个函数在复合商品类CompositeCommodity中实现，它使用迭代器依次调用SingleCommodity单一商品类的IfEnough()方法。如果所有单一商品的库存都充足，则调用Sell()方法逐个将商品卖出，并返回true；否则，返回false表示有商品库存不足。

这种设计中，Command和CommoditySale通过组合关系形成了一个命令模式，通过调用execute()函数来实现具体的商品售卖操作。复合商品售卖流程中的迭代器和各个商品类之间的协作，体现了组合模式和迭代器模式的结合使用。这样的设计使得商品售卖的操作更加灵活，同时保持了命令模式的抽象性和扩展性。

1. 代码展示

- CommoditySale::execute()，商品售卖命令。

- CommodityDisplay::execute()，商品展示命令（复合商品会依次展示其中包含的单件商品）。

template\<classreturn\_T, classparameter\_T\> // 设计模式: Command

classCommand {

public:

    virtualreturn\_Texecute(parameter\_T) =0;

};

classCommodityInformation {

protected:

    stringname, type; // 商品名
    
    intID; // ID
    
    floatprice; // 价格
    
    Shop\*shop; // 商品拥有者(店铺)
    
    intshopID;
    
    virtualboolAdd(CommodityInformation\*commodity);
    
    virtualboolRemove(CommodityInformation\*commodity);
    
    virtualboolHasCommodity(CommodityInformation\*commodity) =0;
    
    virtualboolEnough(intamount) =0;
    
    virtualboolSell(intamount) =0;
    
    virtualvoidDisplay() =0;
    
    friendclassCompositeCommodity;

public:

    friendclassCommodityInformationReader;
    
    friendclassCommodityInformationVipReader;
    
    friendclassCommodityInformationSetter;
    
    friendclassCommoditySale;
    
    friendclassCommodityDisplay;
    
    CommodityInformation(intID, stringname, floatprice, intshopID);

};

classCommoditySale { // 设计模式: command

private:

    CommodityInformation\*source;

public:

    CommoditySale() =default;
    
    CommoditySale(CommodityInformation\*info) : source(info) { }
    
    voidsetCommodityInformation(CommodityInformation\*info){
    
        source=info;
    
    }
    
    boolifEnough(intamount) { returnsource-\>Enough(amount); }
    
    virtualboolexecute(intamount) { returnsource-\>Sell(amount); }

};

classCommodityDisplay { // 设计模式: command

private:

    CommodityInformation\*source;

public:

    CommodityDisplay() =default;
    
    CommodityDisplay(CommodityInformation\*info) : source(info) { }
    
    voidsetCommodityInformation(CommodityInformation\*info){
    
        source=info;
    
    }
    
    virtualvoidexecute() { source-\>Display(); }

};

1. 代价分析

1）类和对象增加：

使用命令模式通常会引入额外的命令类、具体命令类等，增加了系统中类和对象的数量。这可能使得代码结构更加灵活，但也增加了系统的复杂性，可能使代码更难理解和维护。

2）额外的开销：

每个命令对象都需要包含命令的具体实现，这可能导致一些额外的开销。如果系统规模较小，而且命令的复杂性不高，引入命令模式可能显得过于繁琐。

3）理解和维护难度：

引入命令模式后，代码的逻辑可能会分散到多个命令类中，这可能增加理解和维护的难度。特别是在命令类的数量增多时，需要更多的注意力来跟踪和管理各个命令的实现。

1. Iterator 迭代器模式

1. 模式应用场景

迭代器模式被用于遍历复合商品中的所有商品。

1. 类图

![](RackMultipart20231229-1-56770p_html_a2a45235a23886b7.png)

1. 设计思路

CompositeCommodityIterator是复合商品的迭代器，它继承了STL中的iterator\<iterator\_tag, T\>虚基类。通过重载赋值、自增、等于等操作符，CompositeCommodityIterator使得在编写代码时能够轻松使用迭代器来遍历复合商品中的所有商品。这种设计提供了一种方便的方式来访问复合商品内部的各个商品，增加了代码的灵活性和可读性。

（4）代码展示

classCompositeCommodity;  // 设计模式: iterator

classCompositeCommodityIterator : publicstd::iterator\<std::input\_iterator\_tag, CompositeCommodity\> {

protected:

    list\<CommodityInformation\*\>::iteratorcurrent;

public:

    CompositeCommodityIterator(list\<CommodityInformation\*\>::iteratorcommodity);
    
    CompositeCommodityIterator&operator= (constCompositeCommodityIterator&iter);
    
    booloperator!= (constCompositeCommodityIterator&iter);
    
    booloperator== (constCompositeCommodityIterator&iter);
    
    CompositeCommodityIterator&operator++ ();
    
    CompositeCommodityIterator&operator++ (int);
    
    CommodityInformation&operator\* () { return\*\*current; }

};

（5）代价分析

1）增加复杂性：

引入迭代器模式可能增加了系统的抽象层次，涉及到抽象迭代器和具体迭代器的概念。这可能使得系统整体的复杂性增加，尤其是在简单的场景下可能显得过于繁琐。

1. 代码冗余：

在某些情况下，为了实现特定的遍历逻辑，可能需要在具体迭代器中重复实现一些相似的代码。这可能导致代码冗余，增加了维护的难度。

1. 过度设计：

如果系统中只有少量商品或者遍历逻辑非常简单，引入迭代器模式可能被认为是过度设计。在这种情况下，可能有更简单的方式来实现遍历操作，而不引入额外的迭代器结构。

1. 学习成本：

开发人员需要理解迭代器模式的概念和相关的抽象类、接口。在小型项目或者团队中，为了引入迭代器模式而增加的学习成本可能不划算。